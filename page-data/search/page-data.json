{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"백준 1068번 - 트리 문제 트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다. 트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다. 예를 들어, 다음과 같은 트리가 있다고 하자. 입력 첫째 줄에 트리의 노드의 개수…","fields":{"slug":"/1068번-트리/"},"frontmatter":{"date":"November 20, 2022","title":"1068번 트리 Python","tags":["python","graph","dfs"]},"rawMarkdownBody":"\n[백준 1068번 - 트리](https://www.acmicpc.net/problem/1068)\n\n## 문제\n트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.\n\n트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.\n\n예를 들어, 다음과 같은 트리가 있다고 하자.\n\n<img src=\"https://upload.acmicpc.net/560de878-d961-475e-ada4-e1f0774e5a84/-/preview/\" style=\"width: 30%\">\n현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 \n노드이다.\n\n<img src=\"https://upload.acmicpc.net/d46ddf4e-1b82-44cc-8c90-12f76e5bf88f/-/preview/\" style=\"width: 30%\">\n이제 리프 노드의 개수는 1개이다.\n\n## 입력\n첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.\n\n## 출력\n첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.\n\n## 풀이\n재귀함수를 통해 트리를 탐색한다.\n\n### dfs(num, arr)\n1. 요소의 값을 -2로 바꾼다.\n2. `arr`를 탐색하여 부모노드가 `num`인 요소를 찾아 다시 과정을 반복한다.\n3. 과정이 끝나면 삭제된 노드 `k`의 하위노드들은 모두 -2로 갱신되었으므로, `arr`에서 값이 -2가 아니면서 부모가 없는 노드들의 개수를 센다.\n\n```python\nimport sys\n\ndef dfs(num, arr):\n    arr[num] = -2\n    for i in range(len(arr)):\n        if num == arr[i]:\n            dfs(i, arr)\n\nn = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().split()))\nk = int(sys.stdin.readline())\ncount = 0\n\ndfs(k, arr)\ncount = 0\nfor i in range(len(arr)):\n    if arr[i] != -2 and i not in arr:\n        count += 1\nprint(count)\n```"},{"excerpt":"백준 12851번 - 숨바꼭질2 문제 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에…","fields":{"slug":"/12851번-숨바꼭질2/"},"frontmatter":{"date":"November 19, 2022","title":"12851번 숨바꼭질2","tags":["python","graph","bfs"]},"rawMarkdownBody":"\n  \n\n[백준 12851번 - 숨바꼭질2](https://www.acmicpc.net/problem/12851)\n\n  \n\n## 문제\n\n수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.\n\n수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.\n  \n\n## 출력\n\n첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.\n둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.\n  \n\n## 풀이\n\n이전 문제의 출력에서 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수의 출력이 추가되었다. [이전 문제](https://ckdhkdwns-solid-invention-67vpj755rpf47xv-8000.preview.app.github.dev/1698%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/)\n\n1. 이전 문제와 똑같이 visited 리스트를 통해 동생을 찾는 가장 빠른 시간을 계산한다.\n2. visited 에서 다시 한 번 bfs 연산을 통해 동생을 찾는 방법의 수를 계산한다. \n\n동생을 찾는 가장 빠른 시간은 수빈이의 위치에서부터 연산을 시작한 반면,  \n동생을 찾는 방법의 수는 동생의 위치에서부터 연산을 시작한다.\n\n\n```python\nfrom collections import deque\n\nn, k = map(int, input().split())\n\nq = deque([n])\n\n\nvisited = [-1 for i in range(100001)]\nvisited[n] = 0\nwhile q:\n  v = q.popleft()\n  if v == k:\n    break\n  for i in [v-1, v+1, 2*v]:\n    if 0 <= i <= 100000 and visited[i] < 0:\n      visited[i] = visited[v] + 1    \n      q.append(i)\n      \nprint(visited[k])\n\ncount = 0 # 동생을 찾는 방법의 수\n\nqq = deque([k]) # 동생의 위치부터 시작한다\n\nwhile qq:\n  v = qq.popleft()\n  # 수빈이의 시작 위치로 왔으면 \n  if visited[v] == 0:\n    count += 1\n  else:\n    # 현재 위치 v 의 이전 위치를 찾는 과정\n    l = [v-1, v+1, v // 2] if v % 2 == 0 else [v-1, v+1] # 위치가 홀수이면 v/2가 정수가 아니므로 \n    for i in l:\n      if 0 <= i <= 100000 and visited[i] == visited[v] - 1: \n        qq.append(i)\n\nprint(count)\n\n \n\n```"},{"excerpt":"백준 1698번 - 숨바꼭질 문제 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2…","fields":{"slug":"/1698번-숨바꼭질/"},"frontmatter":{"date":"November 19, 2022","title":"1698번 숨바꼭질","tags":["python","graph","bfs"]},"rawMarkdownBody":"\n  \n\n[백준 1698번 - 숨바꼭질](https://www.acmicpc.net/problem/1697)\n\n  \n\n## 문제\n\n수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.\n\n수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.\n  \n\n## 출력\n\n수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.\n  \n\n## 풀이\n\n수빈이가 있을 수 있는 위치는 최대 100,000이므로 100,000 크기의 배열을 만들고 위치를 계산한다.  \n수빈이의 최초 위치를 큐에 삽입하고 bfs를 수행한다.\n\n\n```python\nfrom collections import deque\n\nn, k = map(int, input().split())\n\nq = deque([n])\n\nvisited = [-1 for i in range(100001)]\nvisited[n] = 0\nwhile q:\n  v = q.popleft()\n  if v == k:\n    break\n  for i in [v-1, v+1, 2*v]: # 다음 위치\n    if 0 <= i <= 100000 and visited[i] < 0:  \n      visited[i] = visited[v] + 1    \n      q.append(i)\n      \n\nprint(visited[k])\n```"},{"excerpt":"백준 1916번 - 최소비용 구하기 문제 N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다. 입력 첫째 줄에 도시의 개수 N(…","fields":{"slug":"/1916번-최소비용-구하기/"},"frontmatter":{"date":"November 14, 2022","title":"1916번 최소비용 구하기 Python","tags":["python","dijkstra","graph"]},"rawMarkdownBody":"\n[백준 1916번 - 최소비용 구하기](https://www.acmicpc.net/problem/1916)\n\n---\n## 문제\nN개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.\n\n---\n## 입력\n첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.\n\n그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.\n\n---\n## 출력\n첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.\n\n---\n## 풀이\n\n다익스트라 알고리즘을 통해 해결할 수 있다. \n\n### 다익스트라(데이크스트라, Dijkstra)\n다이나믹 프로그래밍을 활용한 대표적인 최단 경로(Shortest Path) 알고리즘이다. 다익스트라 알고리즘은 가능한 적은 비용으로 가장 빠르게 해답에 도달하는 경로를 찾아내는 대부분의 문제에 응용된다. \n\n- 루빅스 큐브를 푸는 프로그램\n- 내비게이션에서 지도상의 각 도시들의 최단경로\n- 미로탐색 알고리즘\n\n---\n\n### 주요 함수\n- `getMinIndex()` - 방문하지 않은 노드들 중에서 거리가 가장 작은 노드의 인덱스를 가져온다.  \n- `dijkstra(start)` - `start`를 시작 노드로 하여 각 노드들까지의 최단경로를 구한다.\n    1. `start` 노드에 연결되어 있는 다른 노드들까지의 거리를 저장한다.\n    2. `start` 노드에서 가장 가까운 노드를 기준 노드로 설정한다.\n    3. 만약 저장된 거리보다 기준 노드를 거쳐서 다른 노드로 가는 거리가 더 작다면 거리를 갱신한다.\n    4. 다시 `start` 노드에서 가장 가까운 노드를 기준 노드로 설정한다.\n    5. 3번, 4번 과정을 반복한다.\n\n처음 제출할 때는  A -> B 로 가는 노선이 여러 개일 수 있다는 점을 고려하지 않고 입력값을 받아서 틀렸었다.  \n아래 코드에서는 입력값을 받을 때 조건문을 통해서 이 문제를 처리했는데 파이썬에서 제공하는 `heapq` 모듈의 우선순위 큐를 사용하면 이 문제를 쉽게 해결할 수 있다. \n\n```python\nimport sys\n\nn = int(sys.stdin.readline())\nm = int(sys.stdin.readline())\nINF = int(1e9)\nbus = [[INF] * (n + 1) for i in range(n + 1)]\n\nfor i in range(m):\n  c1, c2, cost = map(int, sys.stdin.readline().split())\n  if bus[c1][c2] > cost:\n    bus[c1][c2] = cost\n\nstart, end = map(int, sys.stdin.readline().split())\n\ndistance = [INF for i in range(n + 1)]\n\nvisited = [False for i in range(n + 1)]\n\ndef getMinIndex():\n  minv = INF\n  index = 0\n  for i in range(n + 1):\n    if visited[i]:\n      continue\n    elif distance[i] < minv:\n      minv = distance[i]\n      index = i\n  return index\n\n\ndef dijkstra(start):\n  for i in range(n + 1):\n    if not bus[start][i] == 0:\n      distance[i] = bus[start][i]\n\n  distance[start] = 0\n  for i in range(n + 1):\n    m = getMinIndex()\n    visited[m] = True\n    for j in range(n + 1):\n      if not bus[m][j] == INF:\n        c = distance[m] + bus[m][j]\n        if c < distance[j]:\n          distance[j] = c\n\n\ndijkstra(start)\n\nprint(distance[end])\n  \n```"},{"excerpt":"백준 7569번 - 토마토 문제 철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.\ntomato   창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면,…","fields":{"slug":"/7569번-토마토/"},"frontmatter":{"date":"November 14, 2022","title":"7569번 토마토 Python","tags":["python","bfs","graph"]},"rawMarkdownBody":"\n[백준 7569번 - 토마토](https://www.acmicpc.net/problem/7569)\n\n---\n## 문제\n철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.\n![tomato](https://upload.acmicpc.net/c3f3343d-c291-40a9-9fe3-59f792a8cae9/-/preview/)  \n\n창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.\n\n토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.\n\n---\n## 입력\n첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. \n  \n단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.\n\n토마토가 하나 이상 있는 경우만 입력으로 주어진다\n\n---\n## 출력\n여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.\n\n---\n## 풀이\n항상 2차원 배열만 다루다가 3차원 배열을 다루니 좌표가 헷갈렸다.  \n2차원 배열의 너비 우선 탐색에서 좌표축 하나만 더 추가해주면 해결할 수 있다.\n\n```python\nimport sys \nfrom collections import deque\n\nx, y, z = map(int, sys.stdin.readline().split())\n\nbox = []\nfor i in range(z):\n  temp = []\n  for j in range(y):\n    \n    temp.append(list(map(int, sys.stdin.readline().split())))\n  box.append(temp)\n\ndx = [0, 1, 0, -1, 0, 0]\ndy = [1, 0, -1, 0, 0, 0]\ndz = [0, 0, 0, 0, 1, -1]\n\ndef bfs(p):\n  global box\n  q = deque(p)\n  while q:\n    v = q.popleft()\n    for i in range(6):\n      nx = v[0] + dx[i]\n      ny = v[1] + dy[i]\n      nz = v[2] + dz[i]\n\n      if nx >= z or nx < 0:\n        continue\n      elif ny >= y or ny < 0:\n        continue\n      elif nz >= x or nz < 0:\n        continue\n      elif box[nx][ny][nz] == 0:\n        box[nx][ny][nz] = box[v[0]][v[1]][v[2]] + 1\n        q.append((nx, ny, nz))\n\nb = True\nfor i in range(z):\n  for j in range(y):\n    for k in range(x):\n      if box[i][j][k] == 0:\n        b = False\n        break\n\nif b: # 저장될 때부터 모든 토마토가 익어있을 경우\n  print(0)\nelse:\n  tomato_position = []\n  for i in range(z):\n    for j in range(y):\n      for k in range(x):\n        if box[i][j][k] == 1:\n          tomato_position.append((i, j, k))\n  bfs(tomato_position) # 토마토가 들어있는 위치로 너비 우선 탐색\n\n  # 탐색 이후 다 익었는지 안 익었는지 판별\n  isAll = True \n  for i in range(z):\n    for j in range(y):\n      for k in range(x):\n        if box[i][j][k] == 0:\n          isAll = False\n          break\n\n  if isAll: # 다 익었다면\n    r = []\n    for i in box:\n      temp = []\n      for j in i:\n        temp.append(max(j))\n      r.append(max(temp))\n\n    print(max(r)-1)\n  else: # 다 안 익었다면\n    print(-1)   \n```"},{"excerpt":"문제 상황 를 실행했을 때 아래의 오류와 함께 업데이트가 되지 않았다. 해결 공개키를 등록한다. 구름 컨테이너에서 위 명령어를 입력해도 다시 업데이트를 시도해도 비슷한 오류 발생 시 키를 다시 받는다.","fields":{"slug":"/ubuntu-sudo-apt-get-update/"},"frontmatter":{"date":"October 14, 2022","title":"Ubuntu sudo apt-get update 다음 서명들은 공개키가 없기 때문에 인증할 수 없습니다","tags":["ubuntu","error"]},"rawMarkdownBody":"\n## 문제 상황\n`sudo apt-get update`를 실행했을 때 아래의 오류와 함께 업데이트가 되지 않았다.\n```bash\nW: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://cli-assets.heroku.com/apt ./ InRelease: 다음 서명들은 공개키가 없기 때문에 인증할 수 없습니다: NO_PUBKEY 536F8F1DE80F6A35\nW: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: https://cf-cli-debian-repo.s3.amazonaws.com stable InRelease: 다음 서명이 올바르지 않습니다: EXPKEYSIG 172B5989FCD21EF8 CF CLI Team <cf-cli-eng@pivotal.io>\nW: http://packages.cloudfoundry.org/debian/dists/stable/InRelease 파일을 받는데 실패했습니다  다음 서명이 올바르지 않습니다: EXPKEYSIG 172B5989FCD21EF8 CF CLI Team <cf-cli-eng@pivotal.io>\nW: https://cli-assets.heroku.com/apt/./InRelease 파일을 받는데 실패했습니다  다음 서명들은 공개키가 없기 때문에 인증할 수 없습니다: NO_PUBKEY 536F8F1DE80F6A35\nW: Some index files failed to download. They have been ignored, or old ones used instead.\n```\n\n## 해결\n공개키를 등록한다.\n```bash\n$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys {공캐 키}\n$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 536F8F1DE80F6A35\n```\n\n구름 컨테이너에서 위 명령어를 입력해도 다시 업데이트를 시도해도 비슷한 오류 발생 시 키를 다시 받는다.\n```bash\n$ wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | apt-key add -\n```"},{"excerpt":"인증과 인가 인증과 인가는 둘 다 보안에 관련되어 있어 사람들이 쉽게 오용하는 용어들이다. 인증(Authentication) 인증은 유저나 기기의 신원을 확인하는 절차이다. 예를 들어, 은행에 가서 계좌의 돈을 인출하려 할 때 점원은 당신이 누군지 알기 위해 신상 정보를 물어볼 것이다. 또한 당신이 비행기 티켓을 구매할 때, 티켓을 사용할 자격이 있는지 …","fields":{"slug":"/jwt/"},"frontmatter":{"date":"September 29, 2022","title":"JWT(JSON Web Token)","tags":["jwt"]},"rawMarkdownBody":"\n\n## 인증과 인가\n인증과 인가는 둘 다 보안에 관련되어 있어 사람들이 쉽게 오용하는 용어들이다.\n \n\n### 인증(Authentication) \n인증은 유저나 기기의 신원을 확인하는 절차이다. 예를 들어, 은행에 가서 계좌의 돈을 인출하려 할 때 점원은 당신이 누군지 알기 위해 신상 정보를 물어볼 것이다. 또한 당신이 비행기 티켓을 구매할 때, 티켓을 사용할 자격이 있는지 증명하기 위해 여권을 사용해야 한다. 두 예시는 현실에서 일어나는 신원 인증 절차를 보여준다. \n\n인터넷 상에서, 예를 들어, 당신의 페이스북 프로필이나 회사 메일에 접근하려 할 때는 여권 등을 제시하는 대신에 사용자 이름과 비밀번호를 입력하는 것으로 자신의 신원을 증명한다. 아이디와 비밀번호를 시스템에 입력하면 시스템은 당신의 신원을 확인하고 서비스에 접근할 수 있는 권한을 제공한다. 이 상황에서, 유저는 자신의 신원을 증명하기 위해 인증 요소를 사용한다. 이 인증 요소는 한 개가 될 수도 있고, 여러 개가 될 수도 있다.\n\n### 인가(Authorization)\n인증과 달리 인가는 어떤 개체가 어떤 리소스에 접근할 수 있는지 또는 어떤 동작을 수행할 수 있는지를 검증하는 것, 즉 접근 권한을 얻는 일을 말한다. 예를 들어, 공연장에 입장하기 위해 티켓을 구매할 때, 공연 기획사에서는 당신의 신원에 대해서는 관심이 없다. 당신이 공연장에 입장할 권한이 있는지 여부에만 관심이 있다. 입장 권한을 증명하려면 신분증이나 여권 대신 티켓만 있으면 된다. 티켓이 당신의 신원 정보를 포함하고 있지 않더라도 공연장에 입장할 수 있다.\n\n인터넷에서는 일반적으로 **토큰**을 통해 인가를 다룬다. 유저가 로그인을 하면 앱은 사용자 신원을 바탕으로 인가 세부사항을 가진 토큰을 생성하게 된다. 시스템은 토큰을 이용해서 어떤 권한을 부여할 지, 즉 사용자의 접근을 허용할 지 거부할지를 결정한다.\n\n### 인증 / 인가\n- **인증**은 유저나 디바이스의 신원을 증명하는 것이다.\n- **인가**는 유저나 디바이스에게 접근권한을 부여하는 것이다.\n\n## JWT(JSON Web Token)\n\n- **JWT(Json Web Token)** 은 유저 간의 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 웹 표준(RFC 7519)이다. 이 토큰은 전자서명을 통해 검증되고 신뢰된다, 주로 *HMAC* 알고리즘이나 *RSA*나 *ECDSA*을 통해 서명된다.\n- 세션 방식의 단점을 보완하고자 생긴 기술이다.\n- 사용자의 고유성을 입증할 만한 데이터를 포장하여 토큰을 생성한다. 그리고 해당 토큰을 클라이언트에게 전송받았을 때, 해당 토큰안에 들어있던 고유 데이터로 사용자를 식별하여, 별도의 인증 과정없이 바로 작업을 수행할 수 있다.\n\n### 구성\n\n기본적인 형태는 아래와 같다.  \n\n![](./jwt.png)\n토큰에 있는 `.`을 기준으로 **Header**, **Payload**, **Signature**로 나뉜다.\n\n#### Header   \nSignature를 해싱하기 위한 알고리즘 정보들이 담겨져 있다.\n```json \n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n이 정보는 *BASE64*로 인코딩된다.\n#### Payload\n서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보 *Claims*를 담고있다.\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022\n}\n```\n*Claims*에는 *Registered claims*, *Public claims*, *Private claims*가 있다.\n\n- **Registered claims** - 미리 정의된 *Claims* 세트이다. 보낸 사람, 받는사람, 만료시간 등의 정보를 담고 있다. 필수는 아니다.\n- **Public claims** - 사용자에 의해 임의로 정의되는 *Claims*이다.\n- **Private claims** - *Public claims*와 비슷하게 사용자에 의해 임의로 정의되지만, 유저를 특정할 수 있는 정보들을 담고 있다.\n\n#### Signature\n토큰의 유효성 검증을 위한 문자열이다.\n```javascript\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  your-256-bit-secret\n)\n```\n토큰의 헤더, 페이로드와 서버가 갖고 있는 유일한 key 값을 헤더에서 정의한 알고리즘으로 암호화한다.\n\n\n### 장점\n- 중앙의 인증서버, 데이터 스토어에 대한 의존성이 없어 시스템 수평 확장 유리\n- Bas64 URL Safe Encoding을 사용하기 때문에 URL, Cookie, Header에서 모두 사용할 수 있는 범용성을 거지고 있음\n\n### 단점\n- Payload의 정보가 많아지면 네트워크의 사용량이 증가함\n- 토큰이 클라이언트에 저장되기 때문에 서버에서는 클라이언트의 토큰을 조작할 수 없음\n\n"},{"excerpt":"HTTP HTTP(HyperText Transfer Protocol)은  서버와 클라이언트의 사이에서 어떻게 메시지를 교환할지를 정해 놓은 규칙이다. 요청(Request)과 응답(Response)으로 구성되어 있으며, 일반적으로 80번 포트를 사용한다.  HTTP의 한계 HTTP는 클라이언트가 서버로 요청(Request)을 보내면 서버는 클라이언트에게 응…","fields":{"slug":"/websocket/"},"frontmatter":{"date":"September 26, 2022","title":"Springboot Stomp로 채팅 구현하기","tags":["spring","stomp","websocket"]},"rawMarkdownBody":"\n## HTTP \n<b>HTTP(HyperText Transfer Protocol)</b>은  서버와 클라이언트의 사이에서 어떻게 메시지를 교환할지를 정해 놓은 규칙이다. 요청(Request)과 응답(Response)으로 구성되어 있으며, 일반적으로 80번 포트를 사용한다. \n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/HTTP_logo.svg/1200px-HTTP_logo.svg.png\" style = \"transform: scale(0.5); left: 0\"/>\n\n## HTTP의 한계\n\n<b>HTTP</b>는 클라이언트가 서버로 <b>요청(Request)</b>을 보내면 서버는 클라이언트에게 <b>응답(Response)</b>을 보낸다. 한 쪽 방향으로만 통신을 하는 <b>반이중</b> 방식을 사용하므로 실시간 통신에는 적합하지 않다.  \n  \n물론  이런 문제는 Long polling 방식이나 Ajax를 사용해도 어느정도 해결이 가능하지만 데이터의 빠른 업데이트가 아주 중요한 어플리케이션에서는 실시간 업데이트가 아주 중요하기 때문에 <b>WebSocket</b>을 사용한다.\n\n## WebSocket\n<b>WebSocket</b>은 웹 서버와 웹 브라우저간 실시간 양방향 통신환경을 제공해주는 실시간 통신 기술이며 HTTP와 달리 웹소켓은 <b>전이중</b> 통신을 사용한다.  \n  \n\n연결을 계속 유지하기 때문에 클라이언트와 한 번 연결이 되면 HTTP 사용시 필요없이 발생되는 HTTP와 TCP연결 트래픽을 피할 수 있다. 그리고 HTTP와 같은 80번 포트를 사용하기에 기업용 어플리케이션에 적용할 때 방화벽을 재설정하지 않아도 된다.\n\n## Stomp \n스트리밍 텍스트 지향 메세지 프로토콜로 raw websocket보다 더 많은 프로그래밍 모델을 지원하며 여러 브로커를 사용 가능하다.\n\n---\n## 구현\n\n진행중인 프로젝트에 구현된 채팅 기능의 소스이다.\n\n### WebSocketConfig.java\n\n1. `configureMessageBroker()`  \n메세지를 주고 받을 **Prefix**를 설정한다.\n- `config.enableSimpleBroker('/sub')` - 클라이언트가 메세지를 **구독할(subscribe)** 주소를 지정한다.\n- `config.setApplicationDestinationPrefixes(\"/pub\")` - 클라이언트가 메세지를 **보낼(publish)** 주소를 지정한다.\n\n2. `registerStompEndpoints()`  \nWebsocket 연결을 위한 엔드포인트를 지정해준다. 코드에서는 `/chat`으로 지정해 줬다. \n\n3. `configureClientInboundChannel()`  \n웹 소켓 통신간에 중간에서 정보를 처리하는 **Interceptor**를 지정해준다.  \n프로젝트에서는 메세지 송수신간에 JWT 인증을 위해 Interceptor를 설정해줬다.\n\n```java\n// WebSocketConfig.java\n@Configuration\n@EnableWebSocketMessageBroker\n@RequiredArgsConstructor\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    private final StompHandler stompHandler; \n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(\"/sub\"); \n        config.setApplicationDestinationPrefixes(\"/pub\");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/chat\").setAllowedOriginPatterns(\"*\").withSockJS();\n    }\n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(stompHandler);\n    }\n}\n```\n```java\n// StompHandler.java\n@RequiredArgsConstructor\n@Component\npublic class StompHandler implements ChannelInterceptor {\n    private final TokenProvider tokenProvider;\n\n    @Override\n    public Message<?> preSend(Message<?> message, MessageChannel channel) {\n        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);\n        /** message의 토큰 유효성 검증 */\n        if(accessor.getCommand() == StompCommand.CONNECT) {\n            if(!tokenProvider.validateToken(accessor.getFirstNativeHeader(\"Authorization\")))\n                throw new NotFoundException(\"유저를 찾을 수 없습니다.\");  \n        }   \n        return message;\n    }\n}\n```\n\n### MessageController.java\n\n서버에서 메세지를 받으면 유저와 팀 정보를 통해 Message를 생성하고 송신자와 수신자 모두에게 메세지를 보내는 방식이다.  \n1. `sendingOperations.convertAndSend(String path, Object messageObject)`  \npath를 구독한 유저에게 messageObject를 보낸다.\n\n\n```java\n@MessageMapping(\"/message\")\npublic void handleMessage(MessageDto messageDto, @Header(name = \"Authorization\") String token) {\n    User user = userService.getUserByUserId(tokenProvider.getUserId(token));\n    Team team = teamService.getTeamByTeamId(messageDto.getTeamId());\n    LocalDateTime now = LocalDateTime.now();\n        \n    Message message = Message.builder()\n        .content(messageDto.getContent())\n        .unread(1L)\n        .type(messageDto.getType())\n        .createdDate(now)\n        .sender(user)\n        .receiver(userService.getSimpleUserByUsername(messageDto.getReceiver()))\n        .team(team)\n        .build();\n\n    messageService.createMessage(message);\n\n    \n    sendingOperations.convertAndSend(\n        \"/sub/chat/users/\" + user.getUsername(), \n        MessageDto.from(message));\n    sendingOperations.convertAndSend(\n        \"/sub/chat/users/\" + messageDto.getReceiver(), \n        MessageDto.from(message));\n}\n```"},{"excerpt":"구름 IDE의 컨테이너에 Spring 개발환경을 구축하려고 한다.  OS - Ubuntu 18.04 Generate BLANK container 구름 IDE에 빈 컨테이너를 생성한다. blank Install JDK 17 아래 글을 참고한다. Ubuntu에 Java 설치 Install VScode Extension Pack for Java Extensio…","fields":{"slug":"/init-in-goormide/"},"frontmatter":{"date":"September 10, 2022","title":"VScode에 Spring 개발환경 구축하기","tags":["vscode","spring"]},"rawMarkdownBody":"구름 IDE의 컨테이너에 Spring 개발환경을 구축하려고 한다. \n\nOS - Ubuntu 18.04\n\n### Generate BLANK container\n구름 IDE에 빈 컨테이너를 생성한다.  \n![blank](https://user-images.githubusercontent.com/66898263/189467524-f7288f43-ed41-498d-a8ac-e9e510827974.png)\n\n### Install JDK 17\n아래 글을 참고한다.  \n[Ubuntu에 Java 설치](https://ckdhkdwns.github.io/posts/Ubuntu%EC%97%90%EC%84%9C-%EC%9E%90%EB%B0%94-%EC%84%A4%EC%B9%98/)\n\n### Install VScode Extension Pack for Java \n\n1. Extension Pack for Java  \nPopular extensions for Java development that provides Java IntelliSense, debugging, testing, Maven/Gradle support, project management and more  \n[VS Marketplace Link](https://open-vsx.org/vscode/item?itemName=vscjava.vscode-java-pack)\n![extension-pack-for-java](https://user-images.githubusercontent.com/66898263/189467866-d82c9726-00f1-4f4f-9716-62f37d30d130.png)\n\n2. Spring Boot Extension Pack  \nA collection of extensions for developing Spring Boot applications  \n[VS Marketplace Link](https://open-vsx.org/vscode/item?itemName=Pivotal.vscode-boot-dev-pack)\n![spring-boot-extension-pack](https://user-images.githubusercontent.com/66898263/189467872-02f96318-734c-436a-9cd0-4e0e53af5881.png)\n\n3. Lombok Annotations Support for VS Code  \nA lightweight extension to support Lombok annotations processing in Visual Studio Code  \n[VS Marketplace Link](https://open-vsx.org/vscode/item?itemName=GabrielBB.vscode-lombok)\n![lombok-annotations-support-for-vs-code](https://user-images.githubusercontent.com/66898263/189467874-943442e9-b06d-4eb4-89db-78990a993f24.png)\n\n### Start Project\n\n1. `Ctrl + Shift + P` \n2. `Spring initalizr:Create a Gradle Project...` \n![start](https://user-images.githubusercontent.com/66898263/189468650-cc292cfd-21c1-4b91-ace0-da4d2088b305.png)\n3. 2022-09-10 기준 \n> Spring Boot: 2.7.3  \n> Specify packaging type: Jar  \n> Specify Java version: 17  \n\n로딩 이후 프로젝트가 생성된다.  \n![p](https://user-images.githubusercontent.com/66898263/189468739-cd9971d6-441f-41f1-b175-a0e50f878815.png)"},{"excerpt":"백준 10026번 - 적록색약 문제 적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다. 크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다…","fields":{"slug":"/10026번-적록색약/"},"frontmatter":{"date":"September 09, 2022","title":"10026번 적록색약 Python","tags":["python","bfs","graph"]},"rawMarkdownBody":"\n[백준 10026번 - 적록색약](https://www.acmicpc.net/problem/10026)\n\n---\n## 문제\n적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.\n\n크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)\n\n예를 들어, 그림이 아래와 같은 경우에\n```\nRRRBB\nGGBBB\nBBBRR\nBBRRR\nRRRRR\n```\n적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)\n\n그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.\n\n---\n## 입력\n첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)\n\n둘째 줄부터 N개 줄에는 그림이 주어진다.\n\n---\n## 출력\n적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.\n\n---\n## 풀이\n\n적록색약이 보는 그림의 배열을 만든다. \n원본 배열이 바뀔 때 복사된 배열이 바뀌면 안 되므로 `copy` 모듈의 `deepcopy()` 메서드를 이용해 복사했다. \n\n\n### 얕은 복사 (shallow copy) vs 깊은 복사 (deep copy)\n\n- 얕은 복사 - 원본 객체의 주소값을 복사\n\n```python\n# '='\norigin = [i for i in range(100)]\ncopyed = origin\n\n# slicing\norigin = [i for i in range(100)]\ncopyed = origin[:]\n\n# copy method\norigin = [i for i in range(100)]\ncopyed = origin.copy()\n```\n\n\n- 깊은 복사 - 주소값을 새로 만들어 원본 객체의 값을 삽입 \n\n```python\n# slicing\norigin = [i for i in range(100)]\ncopyed = origin[:]\n\n# deepcopy\nfrom copy import deepcopy\n\norigin = [i for i in range(100)]\ncopyed = deepcopy(origin)\n```\n\n### 해결과정\n\n1. 그림의 크기와 그림의 배열을 입력받음\n2. 원본 배열을 복사하고 적록색약 조건에 맞게 배열 수정\n3. 너비우선탐색을 통해 구역의 수 계산\n\n```python\nimport sys\nimport copy\nfrom collections import deque\n\nn = int(sys.stdin.readline())\npic = []\n\nfor i in range(n):\n    pic.append(list(sys.stdin.readline().strip()))\n\ndx = [0, 0, -1, 1]\ndy = [-1, 1, 0, 0]\n\n# 구역을 F로 칠함\ndef bfs(graph, x, y, key):\n    graph[x][y] = \"F\"\n    q = deque([(x, y)])\n    while q:\n        v = q.popleft()\n        for i in range(4):\n            nx = v[0] + dx[i]\n            ny = v[1] + dy[i]\n            if nx == -1 or ny == -1 or nx == n or ny == n:\n                continue\n            elif not graph[nx][ny] == key or graph[nx][ny] == \"F\":\n                continue\n            else:\n                graph[nx][ny] = \"F\"\n                q.append((nx, ny))\n                \nnormalCount = 0 # 일반인의 구역 수\nblindCount = 0  # 적록색약의 구역 수\n\nblindPic = copy.deepcopy(pic)   # 원본 그림 배열 깊은 복사 \n\n# blindPic의 \"R\"을 \"G\"로 변환\nfor i in range(n):\n    for j in range(n):\n        if blindPic[i][j] == \"R\":\n            blindPic[i][j] = \"G\"\n            \n# 이후 너비우선탐색을 통해 구역의 수를 계산\nfor i in range(n):\n    for j in range(n):\n        if not pic[i][j] == \"F\":\n            bfs(pic, i, j, pic[i][j])\n            normalCount += 1\n        if not blindPic[i][j] == \"F\":\n            bfs(blindPic, i, j, blindPic[i][j])\n            blindCount += 1\n            \nprint(normalCount, blindCount)\n```"},{"excerpt":"gh-pages 설치 홈페이지 주소 추가 에 추가한다. deploy 명령어 추가 에 추가한다. 배포하기 먼저 React 프로젝트가 빌드되어 있어야 gh-pages로 빌드 가능하다. 확인하기 프로젝트 저장소의  브랜치에서 초록색 체크가 뜨면 배포가 완료된 것이다. gp","fields":{"slug":"/gh-pages-deploy/"},"frontmatter":{"date":"September 09, 2022","title":"gh-pages로 React 배포하기","tags":["react","github","gh-pages"]},"rawMarkdownBody":"\n\n### gh-pages 설치\n```bash\nnpm install gh-pages --save-dev\n```\n### 홈페이지 주소 추가\n`pakage.json`에 추가한다.\n```json\n\"homepage\": \"http://{사용자 이름}.github.io/{프로젝트 이름}\"\n\n\"homepage\": \"http://ckdhkdwns.github.io/typingPractice\"\n```\n### deploy 명령어 추가\n`pakage.json`에 추가한다.\n```json\n\"scripts\": {\n  \"deploy\": \"gh-pages -d build\"\n}\n```\n### 배포하기\n먼저 React 프로젝트가 빌드되어 있어야 gh-pages로 빌드 가능하다.\n```bash\nnpm run-script build\nnpm run deploy\n```\n\n### 확인하기\n프로젝트 저장소의 `gh-pages` 브랜치에서 초록색 체크가 뜨면 배포가 완료된 것이다.\n\n![gp](https://user-images.githubusercontent.com/66898263/189485906-7e2666d5-7ae4-48f7-8ecf-44f761b7fd80.png)\n"},{"excerpt":"ASCII 인코딩을 꺼준다. 파일을 읽을 때  코덱으로 인코딩한다.","fields":{"slug":"/crack-korean/"},"frontmatter":{"date":"September 09, 2022","title":"Flask Response 한글 깨짐 현상","tags":["flask","python","error"]},"rawMarkdownBody":"\nASCII 인코딩을 꺼준다.\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\napp.config['JSON_AS_ASCII'] = False\n```\n\n\n+ 파일을 읽을 때 `utf-8` 코덱으로 인코딩한다. \n```python\nwith open('file.txt', encoding = 'utf-8') as file:\n    ...\n```\n\n"},{"excerpt":"Flask 공식문서 A Minimal Application 플라스크 앱의 형태는 다음과 같다.  클래스를 import한다. 이란 instance를 만든다. 함수를 통해 어떤 URL이  앱의 함수를 실행시킬건지 지정한다.  함수는 사용자의 화면에 출력할 메세지를 리턴한다. 이 함수를  로 저장한다. (충돌 방지를 위해 이름을 로 저장하지 않도록 한다.)\n이…","fields":{"slug":"/quick-start/"},"frontmatter":{"date":"September 09, 2022","title":"Flask - Quick start","tags":["flask","python"]},"rawMarkdownBody":"\n[Flask 공식문서](https://flask.palletsprojects.com/en/2.2.x/)\n\n## A Minimal Application\n\n플라스크 앱의 형태는 다음과 같다.\n\n```python\n\nfrom flask import Flask\n\napp = Flask(__name__) \n\n@app.route(\"/\")\ndef  hello_world():\n    return  \"<p>Hello, World!</p>\"\n\n#app.run()\n```\n\n1.  `Flask` 클래스를 import한다.\n2.  `app`이란 instance를 만든다.\n3.  `route()`함수를 통해 어떤 URL이 `Flask` 앱의 함수를 실행시킬건지 지정한다.\n4.  `hello_word()` 함수는 사용자의 화면에 출력할 메세지를 리턴한다.\n\n이 함수를 `app.py` 로 저장한다. (충돌 방지를 위해 이름을 `flask.py`로 저장하지 않도록 한다.)\n이후 `flask` 명령어나 `python -m flask`를 통해 앱을 실행한다.\n```bash\n\n$ flask --app app run\n* Serving Flask app 'app'\n* Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n```\n\n## Routing\n\n현대의 웹 어플리케이션들은 유저를 돕기 위해 의미있는 URL들을 사용한다.\n`route()`함수를 통해 함수와 URL을 연결해준다.\n\n```python\n@app.route('/')\ndef  index():\n    return  'Index Page'\n\n@app.route('/hello')\ndef  hello():\n    return  'Hello, World'\n```\n\n## Variable Rules\n`<variable_name>`을 URL에 삽입해 변수를 받아올 수 있다. 함수는 `<variable_name>`의 값을 매개변수로 받는다.\n```python\nfrom markupsafe import escape\n\n@app.route('/user/<username>')\ndef  show_user_profile(username):\n# show the user profile for that user\n    return  f'User {escape(username)}'\n\n@app.route('/post/<int:post_id>')\ndef  show_post(post_id):\n# show the post with the given id, the id is an integer\n    return  f'Post {post_id}'\n\n@app.route('/path/<path:subpath>')\ndef  show_subpath(subpath):\n# show the subpath after /path/\n    return  f'Subpath {escape(subpath)}'\n\n```\n\n## HTTP Methods\n웹 어플리케이션은 URL에 접근할 때 각각 다른 HTTP 메소드들을 사용한다. 기본적으로, `@app.route()`는 `GET` 요청에만 응답한다. `methods` 매개변수를 이용해 HTTP 메소드들을 조작할 수 있다.\n\n```python\nfrom flask import request\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        return do_the_login()\n    else:\n        return show_the_login_form()\n```\n위의 예제는 각각의 메소드들을 하나의 함수안에 라우팅했다. \n\n아래와 같이 `@app.get()`과 `@app.post()`를 사용하면 각각의 메서드들을 조작하는 함수들을 만들 수 있다. \n```python\n@app.get('/login')\ndef login_get():\n    return show_the_login_form()\n\n@app.post('/login')\ndef login_post():\n    return do_the_login()\n```\n## Static Files\n동적 웹 애플리케이션은 정적 파일들도 필요하다. 간단하다. `static`폴더를 생성하면 `/static` 경로에서 사용 가능하다.\n\nURL을 생성하고 싶다면 아래와 같이 하면 된다.\n```python\nurl_for('static', filename='style.css')\n```\n물론 `static/style.css`가 존재해야 한다.\n\n## Rendering Templates\n`render_template()`메소드를 통해 템플릿을 렌더링할 수 있다. \n\n```python\nfrom flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n```\n`render_template`는 `template` 폴더에서 `hello.html`을 찾고 `name` 의 값을 넘겨준다.\n\n```xml\n<!-- template/hello.html -->\n<!doctype html>\n<title>Hello from Flask</title>\n{% if name %}\n  <h1>Hello {{ name }}!</h1>\n{% else %}\n  <h1>Hello, World!</h1>\n{% endif %}\n```"},{"excerpt":"Spring 공부 도중 VScode extension 호환성 문제로 Java 17을 설치해야 했다.  OS: Ubuntu 18.04   Installed Java version: 11 error-extension 1. 기존에 있던 Java 제거 설치되어 있는 모든 openjdk를 삭제한다. 2. Ubuntu 내의 패키지들 최신화 3. OpenJDK 17 …","fields":{"slug":"/install-java/"},"frontmatter":{"date":"September 07, 2022","title":"Ubuntu에서 Java 설치","tags":["ubuntu","java"]},"rawMarkdownBody":" \nSpring 공부 도중 VScode extension 호환성 문제로 Java 17을 설치해야 했다. \n- OS: Ubuntu 18.04  \n- Installed Java version: 11\n\n![error-extension](https://user-images.githubusercontent.com/66898263/189289285-640086de-65c5-4c9a-ada6-3f2599c9bf94.png)\n\n## 1. 기존에 있던 Java 제거\n설치되어 있는 모든 openjdk를 삭제한다.\n```bash\nsudo apt-get remove openjdk*\n```\n## 2. Ubuntu 내의 패키지들 최신화\n```bash\nsudo apt-get update\nsudo apt-get upgrade\n```\n## 3. OpenJDK 17 설치\n- (Ubuntu 20.04는 기본적으로 Java17이 내포되어 있다.)\n\n```bash\nsudo apt install openjdk-17-jdk\n```\n이후 버전 확인 \n```bash\njava -version\n\n# Expected result\nopenjdk version \"17.0.4\" 2022-07-19\nOpenJDK Runtime Environment (build 17.0.4+8-Ubuntu-118.04)\nOpenJDK 64-Bit Server VM (build 17.0.4+8-Ubuntu-118.04, mixed mode, sharing)\n```"},{"excerpt":"백준 14502번 - 연구소 문제 인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다. 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며,…","fields":{"slug":"/14502번-연구소/"},"frontmatter":{"date":"September 04, 2022","title":"14502번 연구소 Python","tags":["python","brute-force","bfs"]},"rawMarkdownBody":"\n  \n\n[백준 14502번 - 연구소](https://www.acmicpc.net/problem/14502)\n\n  \n\n## 문제\n\n인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.\n\n연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. \n\n일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.\n\n예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.\n\n```\n2 0 0 0 1 1 0\n0 0 1 0 1 2 0\n0 1 1 0 1 0 0\n0 1 0 0 0 0 0\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0\n```\n이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.\n\n2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.\n```\n2 1 0 0 1 1 0\n1 0 1 0 1 2 0\n0 1 1 0 1 0 0\n0 1 0 0 0 1 0\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0\n```\n바이러스가 퍼진 뒤의 모습은 아래와 같아진다.\n```\n2 1 0 0 1 1 2\n1 0 1 0 1 2 2\n0 1 1 0 1 2 2\n0 1 0 0 0 1 2\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 1 0 0 0 0 0\n```\n벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.\n\n연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)\n\n둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.\n\n빈 칸의 개수는 3개 이상이다.\n\n  \n\n## 출력\n\n첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.\n\n  \n## 풀이\n\n해결과정은 아래와 같다.\n\n1. 입력값을 입력받는다.\n2. 연구소에서 벽의 좌표와 바이러스의 좌표를 배열에 저장해둔다.\n3. `bfs(t, viruses, i)`에서 \n- `t`: 배열 `lab`을 깊게 복사한 배열\n- `viruses`: 바이러스의 좌표들\n- `i`: 공백 배열중 3개로 조합한 배열\n\n4. 너비 우선 탐색을 통해 각 경우마다 안전영역의 크기를 구한다.\n5. 안전영역의 크기 중 최댓값을 출력한다.\n\n```python\n#14502번 연구소\nimport sys\nimport copy\nfrom collections import deque   \nfrom itertools import combinations  \n    \ndef bfs(graph, viruses, blocks):\n    cnt = 0\n    dx = [0, 0, -1, 1]\n    dy = [-1, 1, 0, 0]\n    q = deque(viruses)\n    while q:\n        v = q.popleft()\n        #사방의 값 확인\n        for i in range(4):\n            nx = v[0] + dx[i]\n            ny = v[1] + dy[i]\n            if nx == -1 or ny == -1 or nx == n or ny == m:\n                continue\n            elif not graph[nx][ny] == 0:\n                continue\n            elif (nx, ny) in blocks:\n                continue\n            else:\n                q.append((nx, ny))\n                graph[nx][ny] = 2 \n    #안전영역의 크기 구하기\n    for i in range(n):\n        for i in graph[i]:\n            if i == 0:\n                cnt += 1\n    return cnt\n\n#입력값 입력받기\nn, m = map(int, sys.stdin.readline().split())\nlab = []\nfor i in range(n):\n    lab.append(list(map(int, sys.stdin.readline().split())))\n\n#공백과 바이러스의 좌표 구하기  \nspaces = []\nviruses = []\nfor i in range(n):\n    for j in range(m):\n        if lab[i][j] == 0:\n            spaces.append((i, j))\n        if lab[i][j] == 2:\n            viruses.append((i, j))\n\n#안전영역의 크기들\nresult = []\n\nfor i in list(combinations(spaces, 3)): #공백배열 중 3개 조합\n    t = copy.deepcopy(lab) #깊은복사를 통해 lab배열이 바뀌는 걸 막음\n    result.append(bfs(t, viruses, i))\n    \nprint(max(result)-3) #벽의 개수(3) 빼기\n```"},{"excerpt":"백준 1541번 - 잃어버린 괄호 문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.   그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오. 입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘…","fields":{"slug":"/1541번-잃어버린-괄호/"},"frontmatter":{"date":"September 03, 2022","title":"1541번 잃어버린 괄호 Python","tags":["python","string","greedy","parsing"]},"rawMarkdownBody":"\n  \n\n[백준 1541번 - 잃어버린 괄호](https://www.acmicpc.net/problem/1541)\n\n  \n\n## 문제\n\n세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.  \n\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.\n\n  \n\n## 출력\n\n첫째 줄에 정답을 출력한다.\n\n  \n\n## 풀이\n\n최솟값을 구하기 위해선 `-`를 기준으로 괄호를 치면 된다.  \n  \n예를 들어,  \n`5+10-20+30-40+50-60+70`라는 식에서   \n`-`를 기준으로 괄호를 치면   \n`(5+10)-(20+30)-(40+50)-(60+70)`가 된다.  \n  \n첫번째 값에서 계속 이후 값들을 최대로 빼므로 최솟값을 구할 수 있다. \n\n```python\ns = input().split(\"-\")\n\nresult = sum(map(int, s[0].split(\"+\"))) #첫번째 괄호\n\nfor i in range(1, len(s)): #이후의 괄호들\n    result -= sum(map(int, s[i].split(\"+\")))\n        \nprint(result)\n```"},{"excerpt":"백준 1038번 - 감소하는 수 문제 음이 아닌 정수 X의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소한다면, 그 수를 감소하는 수라고 한다. 예를 들어, 321과 950은 감소하는 수지만, 322와 958은 아니다. N번째 감소하는 수를 출력하는 프로그램을 작성하시오. 0은 0번째 감소하는 수이고, 1은 1번째 감소하는 수이다. 만약 N번째 감소하…","fields":{"slug":"/1038번-감소하는-수/"},"frontmatter":{"date":"July 29, 2022","title":"1038번 감소하는 수 Python","tags":["python","brute-force","back-tracking"]},"rawMarkdownBody":"\n[백준 1038번 - 감소하는 수](https://www.acmicpc.net/problem/1038)\n\n## 문제\n음이 아닌 정수 X의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소한다면, 그 수를 감소하는 수라고 한다. 예를 들어, 321과 950은 감소하는 수지만, 322와 958은 아니다. N번째 감소하는 수를 출력하는 프로그램을 작성하시오. 0은 0번째 감소하는 수이고, 1은 1번째 감소하는 수이다. 만약 N번째 감소하는 수가 없다면 -1을 출력한다.\n\n## 입력\n첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다.\n\n## 출력\n첫째 줄에 N번째 감소하는 수를 출력한다.\n\n## 풀이\n\n9876543210보다 큰 감소하는 수는 없으므로 감소하는 수의 개수는 일정하다. \n\n1. 숫자 1개부터 10개까지 `combinations` 함수를 이용해 모든 수의 조합을 만든다.\n2. 수들을 역순으로 정렬한다.\n3. 정렬된 수들을 합쳐서 리스트에 저장한다.\n4. `arr[n]`출력을 시도하고 만약 실패한다면 `n`번째 감소하는 수가 없다는 뜻이므로 `-1`을 출력한다.\n\n```python\nimport sys\nfrom itertools import combinations\n\nn = int(sys.stdin.readline())\n\narr = []\nfor i in range(1, 11):\n    for j in combinations(range(0, 10), i):\n        temp = list(j)\n        temp.sort(reverse=True)\n        arr.append(\"\".join(map(str, temp)))\n\narr = list(map(int, arr))\narr.sort()\ntry:\n    print(arr[n])\nexcept:\n    print(-1)\n```"},{"excerpt":"백준 1309번 - 동물원 문제 어떤 동물원에 가로로 두칸 세로로 칸인 아래와 같은 우리가 있다. 이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다. 동물원 조련사의 머리가 아프지 않도록 우리가  배열에 사자를 배치하는 경우의 수…","fields":{"slug":"/1309번-동물원/"},"frontmatter":{"date":"July 26, 2022","title":"1309번 동물원 Python","tags":["python","dynamic programing"]},"rawMarkdownBody":"\n[백준 1309번 - 동물원](https://www.acmicpc.net/problem/1309)\n\n## 문제\n어떤 동물원에 가로로 두칸 세로로 $N$칸인 아래와 같은 우리가 있다.\n\n이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.\n\n동물원 조련사의 머리가 아프지 않도록 우리가 $2 \\times N$ 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.\n\n## 입력\n첫째 줄에 우리의 크기 $N(1≤N≤100,000)$이 주어진다.\n\n## 출력\n첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.\n\n## 풀이\n\n점화식만 알아내면 간단하게 풀 수 있다. \n\n- $n = 1$일 때 경우의 수는 **3**가지이다.\n- $n = 2$일 때 경우의 수는 **7**가지이다.\n- $n = 3$일 때 경우의 수는 **17**가지이다.\n- $n = 4$일 때 경우의 수는 **41**가지이다.\n\n$f(n) = f(n-1) \\times 2 + f(n-2)$임을 알 수 있다. \n\n\n이를 이용해 코드를 작성하면 \n```python\nn = int(input())\n\nif n == 1:\n    print(3)\nelif n == 2:\n    print(7)\nelse:\n    a, b = 3, 7\n    for i in range(n-1):\n        a, b = b, b*2 + a\n    print(a%9901)\n```\n\n반복문으로 점화식을 계산할 수 있도록 하였다.\n```python\na, b = 3, 7      # n = 1, n = 2일 때\nfor i in range(n-1):\n    a, b = b, b*2 + a\n```"},{"excerpt":"백준 1389번 - 케빈 베이컨의 6단계 법칙 문제 케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다. 예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만…","fields":{"slug":"/1389번-케빈-베이컨의-6단계-법칙/"},"frontmatter":{"date":"July 25, 2022","title":"1389번 케빈 베이컨의 6단계 법칙 Python","tags":["python","bfs"]},"rawMarkdownBody":"\n---\n\n[백준 1389번 - 케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)\n\n## 문제\n케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.\n\n예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?\n\n천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.\n\n케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.\n\n오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.\n\n예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.\n\n1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.\n\n2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.\n\n3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.\n\n4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.\n\n마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.\n\n5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.\n\nBOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.\n\n## 입력\n첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.\n\n## 출력\n첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.\n\n\n## 풀이\n\nBFS를 이용해 해결 가능하다\n\n```python\nfrom collections import deque\nimport sys\n\nn, m = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n+1)]\n\n#입력값을 정렬한다. 배열의 인덱스가 1이면 1의 친구들이 나오게 정렬한다.\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n    \n\ndef bfs(graph, start):\n\tnum = [0 for _ in range(n+1)]  #start가 갖는 각 사람의 단계의 수를 담는다.\n\tvisited = [start]    \n\tqueue = deque([start])  #큐 생성\n\twhile queue:\n\t\tv = queue.popleft()\n\t\tfor i in graph[v]:\n\t\t\tif i not in visited:\n\t\t\t\tnum[i] = num[v] + 1  \n\t\t\t\tvisited.append(i)\n\t\t\t\tqueue.append(i)\n    \n\treturn sum(num)\n                \ns = []\nfor i in range(1, n+1):\n    s.append(bfs(graph, i))\n\n#최소값의 인덱스 + 1\nprint(s.index(min(s))+1)\n```\n#### 주요 코드\n1. `graph[v]` == v의 친구들\n2. 만약 v의 친구들이 `visited`리스트 안에 없다면\n3. `num[i] = num[v] + 1` 큐에서 뽑아온 사람의 단계 수 + 1 = 큐에서 뽑아온 사람의 친구들의 단계 수\n4. `visited`와 `queue`에 v의 친구 추가\n\n```python\nfor i in graph[v]:\n\tif i not in visited:\n\t num[i] = num[v] + 1\n\t\tvisited.append(i)\n\t\tqueue.append(i)\n```\n"},{"excerpt":"백준 2110번 - 공유기 설치 문제 도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다. 도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가…","fields":{"slug":"/2110번-공유기-설치/"},"frontmatter":{"date":"July 24, 2022","title":"2110번 공유기 설치 Python","tags":["python","binary-search"]},"rawMarkdownBody":"\n[백준 2110번 - 공유기 설치](https://www.acmicpc.net/problem/2110)\n\n## 문제\n도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.\n\n도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.\n\nC개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.\n\n## 입력\n첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.\n\n## 출력\n첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.\n\n## 풀이\n\n처음에는 완전탐색으로 접근했었다.   \n\n1. 공유기를 설치하는 집의 조합을 모두 구한다.\n2.  각 조합마다 공유기 사이의 거리 중 최솟값을 구한다.\n3.  그 중 최댓값을 구한다.\n\n```python\n#값 입력\nn, c = map(int, input().split())\nhome_pos = []\n\nfor i in range(n):\n    home_pos.append(int(input()))\n    \nhome_pos.sort() #정렬\ncombinations = []\n\n#조합 구하기\ndef getCombinations(li, result, depth):\n    if depth == c:\n        combinations.append(result)\n    else:\n        for i in range(len(li)):\n            v = li[i]\n            temp1 = list(li)\n            temp2 = list(result)\n            del temp1[:i+1]\n            temp2.append(v)\n            getCombinations(temp1, temp2, depth + 1)\n            \ngetCombinations(home_pos, [], 0)\n\n#가장 인접한 두 공유기 사이의 거리\ndistance=-1\nfor i in combinations:\n    temp = []\n    for j in range(len(i)-1):\n        temp.append(abs(i[j]-i[j+1]))\n    if min(temp) > distance:\n        distance = min(temp)\n    \n#그 중 최대거리 출력\nprint(distance)\n```\n\n  \n하지만 메모리초과로 인해 고생하다가 이분탐색으로 해결해야 함을 알았다. \n\n\n\n---\n## 이분 탐색(Binary Search)\n- 이진 탐색이란 데이터가 정렬돼 있는 배열에서 탐색 범위를 절반식 잘라서  값을 찾아내는 알고리즘이다. \n- 데이터가 정렬되어 있어야 사용할 수 있다.\n- `start`, `mid`, `end` 3개의 변수를 통해 이분 탐색을 할 수 있다.   \n\n이를 통해서 코드를 짰다.\n\n1. `start`와 `end` 를 각각 집 사이의 최소거리, 최대거리로 설정한다.\n2. 반복문에서 `mid`의 값을 설정한다.\n3. `mid`의 거리를 두고 공유기를 설치할 수 있으면 `start`를 `mid+1` 위치로 이동한다. 만약 설치할 수 없다면 `end`를 `mid-1`의 위치로 이동한다.\n4. 결과 출력  \n\n```python\nimport sys\n\n#값 입력\nn, c = map(int, sys.stdin.readline().split())\nhome_pos = []\n\nfor i in range(n):\n    home_pos.append(int(sys.stdin.readline()))\n    \nhome_pos.sort() #정렬\n\nstart = 1 #집 사이의 최소거리\nend = home_pos[-1] - home_pos[0] #집 사이의 최대거리\nresult = 0\n\n#이분 탐색\nwhile start <= end:\n    mid = (start + end) // 2\n    count = 1  #공유기의 개수\n    v = home_pos[0]  #최소 좌표\n    for i in home_pos:\n        if i >= v + mid:  #mid만큼 거리를 두고 공유기를 설치할 수 있으면 count ++\n            v = i\n            count += 1\n            \n    #count가 c보다 크면 조건 성립, 거리 늘림\n    if count >= c:\n        start = mid + 1\n        result = mid\n    #아니라면 거리 좁힘\n    else:\n        end = mid - 1\n        \nprint(result)\n```\n"},{"excerpt":"실습환경 칼리 리눅스에서 아파치 웹 서버를 열어 실습을 진행하였다.  Kali-Linux: 5.4.0 Apache: 2.4.41 코드 분석 login.php\n페이지에 들어가면 간단한 로그인 폼이 있다.\nlogin-form 로그인을 처리하는 코드이다. POST 형식으로 id와 pw를 받고 query 구문을 통해 DB에서 id와 pw가 일치하는 정보를 찾는다…","fields":{"slug":"/sql-injection/"},"frontmatter":{"date":"July 22, 2021","title":"SQL Intection 실습","tags":["sql-injection","hacking"]},"rawMarkdownBody":"\n## 실습환경\n칼리 리눅스에서 아파치 웹 서버를 열어 실습을 진행하였다.\n\n\n>  Kali-Linux: 5.4.0  \n> Apache: 2.4.41\n\n\n## 코드 분석\n\nlogin.php\n페이지에 들어가면 간단한 로그인 폼이 있다.\n![login-form](./login-form.jpg)\n```javascript\n    ...\n   \t$id=$_POST['id'];\n        $pw=$_POST['pw'];\n \n        $query = \"select * from member where id='$id' and pw='$pw'\";\n        $result = $connect->query($query);\n \n \n        if(mysqli_num_rows($result)==1) {\n                 $_SESSION['userid']=$id;\n                if(isset($_SESSION['userid'])){\n                ?>      <script>\n                                alert(\"로그인 되었습니다.\");\n                                location.replace(\"./index.php\");\n                        </script>\n                <?php\n                } else{\n                        echo \"session fail\";\n                } \n        } else{\n                ?> <script>\n                       alert(\"아이디 혹은 비밀번호가 잘못되었습니다.\");\n                       history.back();\n                </script> <?php\n    ...\n```\n로그인을 처리하는 코드이다. POST 형식으로 id와 pw를 받고 query 구문을 통해 DB에서 id와 pw가 일치하는 정보를 찾는다. \n\n취약점이 있는 부분은 바로 아래 코드 부분이다.\n\n\n```php\n\t$query = \"select * from member where id='$id' and pw='$pw'\";\n        $result = $connect->query($query);\n \n \n        if(mysqli_num_rows($result)==1) { ...\n```\n요청에서 받아온 id와 pw값을 검증 없이 그대로 사용하고 있다. \npw값에 `' or id='admin'#`를 대입하면 로그인 폼이 우회된다.\n![login-success](./login-success.jpg)\n\n\n## 원리\n쿼리 부분을 다시 보자.\n\n```php\n\t$query = \"select * from member where id='$id' and pw='$pw'\";\n```\n여기서 pw값에 `' or id='admin'#`가 들어간다면\n```php\n\t$query = \"select * from member where id='$id' and pw='' or id='admin'#'\";\n```\n위와 같은 형태가 된다.   \nSQL상에서 AND연산자는 OR연산자보다 우선순위가 높다. \n[MYSQL 연산자 우선순위](https://www.mysqltutorial.org/mysql-or/)\n\n```php\n\t$query = \"select * from member where (id='$id' and pw='') or id='admin'#'\";\n```\n결국 쿼리문은 DB에서 id가 admin인 row를 찾고 인증을 우회하게 되는 것이다. \n\n제일 상단의 코드를 보면 사용자가 입력한 id값에 따라 세션이 생성된다. 즉, 공격자가 유저들의 id를 알기만 하면 그 유저의 권한을 가질수 있게 되는 것이다.\n\n\n\n## 취약점 보완\n1. `SELECT`, `UNION`과 같은 SQL 함수와 특수문자를 필터링\n\n2. id와 pw를 한 번에 검색하는 방식 -> id만 검색하고 pw는 id 검색 후 나온 row의 pw와 대조\n\n3. if문 안의 동치연산자 `==`를 `===`로 변경 \n\n\n\n## 결과\n```javascript\n\t$id=preg_replace(\"/[\\'\\;\\\"\\=\\-\\-\\#\\/*]+/\",\"\", $_POST['id']);\n        $pw=$_POST['pw'];\n\n        if(preg_match('/(union|select|from|where)/i', $id)){\n                exit();\n        }\n        $query = \"select * from member where id='$id'\";\n        $result = $connect->query($query);\n \n \n        if(mysqli_num_rows($result) === 1) {\n                $row=mysqli_fetch_assoc($result);\n                if($row['pw'] === $pw) {\n                        $_SESSION['userid']=$id;\n                        if(isset($_SESSION['userid'])) {\n                        ?> <script>\n                                alert(\"로그인 되었습니다.\");\n                                location.replace(\"./index.php\");\n                        </script> <?php\n                        } else {\n                                echo \"session fail\";\n                        } \n                } else {\n                        ?> <script>\n                               alert(\"아이디 혹은 비밀번호가 잘못되었습니다.\");\n                               history.back();\n                        </script> <?php\n                }\n        } else {\n                ?> <script>\n                       alert(\"아이디 혹은 비밀번호가 잘못되었습니다.\");\n                       history.back();\n                </script> <?php\n        }\n```"}]}},"pageContext":{}},"staticQueryHashes":[]}